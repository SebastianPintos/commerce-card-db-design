= Bases de Datos: Trabajo Práctico
@SebastianPintos <spintos@campus.ungs.edu.ar>; @PierozziLuque <solpierozzi@hotmail.com>; jmcorbera <jmcorbera@gmail.com>;
v1, {docdate}. 	Rondelli, Hernan Daniel y Czemerinski, Hernan (COM-01)
:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4

== Introducción

=== Creación de la Base de Datos 

- Se deberá:
* Crear las tablas respetando los nombres de tablas, atributos y tipos de datos especificados.
* Agregar las PK’s y FK’s de todas las tablas, por separado de la creación de las tablas. 
* Permitir al usuario borrar todas las PK’s y FK’s, si así lo desea.

=== Instancia de los datos

- Se deberán cargar 20 clientes y 20 comercios. Todos los clientes tendrán una tarjeta,
excepto dos clientes que tendrán dos tarjetas cada uno. 
- Una tarjeta deberá estar expirada en su fecha de vencimiento.
- La tabla cierre deberá tener los cierres de las tarjetas para todo el año 2020.

=== Stored procedures o triggers

El trabajo práctico deberá incluir los siguientes stored procedures ó triggers:

- Autorización de compra: Deberá recibir los datos de una compra número de tarjeta, código de seguridad, número de comercio y monto y que devuelva true si se autoriza la compra ó false si se rechaza. El procedimiento
deberá validar los siguientes elementos antes de autorizar:

* Que el número de tarjeta sea existente, y que corresponda a alguna tarjeta vigente.
En caso de que no cumpla, se debe cargar un rechazo con el mensaje: tarjeta no
válida ó no vigente.

* Que el código de seguridad sea el correcto. En caso de que no cumpla, se debe
cargar un rechazo con el mensaje: código de seguridad inválido.

* Que el monto total de compras pendientes de pago más la compra a realizar no
supere el límite de compra de la tarjeta. En caso de que no cumpla, se debe cargar
un rechazo con el mensaje: supera límite de tarjeta.

* Que la tarjeta no se encuentre vencida. En caso de que no cumpla, se debe cargar
un rechazo con el mensaje: plazo de vigencia expirado.

* Que la tarjeta no se encuentre suspendida. En caso que no cumpla, se debe cargar
un rechazo con el mensaje la tarjeta se encuentra suspendida.
Si se aprueba la compra, se deberá guardar una fila en la tabla compra, con los datos
de la compra.

- Generación del resumen el trabajo práctico deberá contener la lógica que reciba
como parámetros el número de cliente, y el periodo del año, y que guarde en las
tablas que corresponda los datos del resumen con la siguiente información: nombre
y apellido, dirección, número de tarjeta, periodo del resumen, fecha de vencimiento,
todas las compras del periodo, y total a pagar.

- Alertas a clientes: Se deberá proveer la lógica que genere alertas por posibles fraudes. 
Existe un Call Centre que ante cada alerta generada automáticamente, realiza un llamado telefónico
a el cliente, indicándole la alerta detectada, y verifica si se trató de un fraude ó no. 
Se supone que la detección de alertas se ejecuta
automáticamente con cierta frecuencia. Se pide detectar y almacenar las siguientes alertas:
* Todo rechazo se debe ingresar automáticamente a la tabla de alertas. No puede
haber ninguna demora para ingresar un rechazo en la tabla de alertas, se debe
ingresar en el mismo instante en que se generó el rechazo.
* Si una tarjeta registra dos compras en un lapso menor de un minuto en comercios
distintos ubicados en el mismo código postal.
* Si una tarjeta registra dos compras en un lapso menor de 5 minutos en comercios
con diferentes códigos postales.
* Si una tarjeta registra dos rechazos por exceso de límite en el mismo día, la tarjeta
tiene que ser suspendida preventivamente, y se debe grabar una alerta asociada a
este cambio de estado.
- Se deberá crear una tabla con consumos virtuales para probar el sistema, la misma deberá
contener los atributos: nrotarjeta, codseguridad, nrocomercio, monto. Y se deberá
hacer un procedimiento de testeo, que pida autorización para todos los consumos virtuales.
- Todo el código SQL escrito para este trabajo práctico, deberá poder ejecutarse
desde una aplicación CLI escrita en Go.

=== JSON y Base de datos NoSQL

Se deberá guardar los datos de clientes, tarjetas, comercios, y compras (tres por cada entidad)
en una base de datos NoSQL basada en JSON. Para ello, utilizar la base de datos BoltDB.
Este código, también deberá ejecutarse desde una aplicación CLI escrita en Go.

== Descripción
El programa se organiza en dos carpetas y un archivo escrito en Go (main) que sirve como aplicación CLI:

- Carpeta _sql_:
* Contiene toda la lógica asociada a los ítems: Creación de la base de datos, Instancia de los datos y _Stored procedures_ o _triggers_. 

- Carpeta _no-sql_: 
* Contiene la resolución del ítem _JSON_ y Base de datos _NoSQL_.

Se cambiaron los tipos de datos de: _nrooperacion, nrorechazo, nroresumen_ y _nroalerta_ por _serial_ para facilitar el autoincremento de estos campos.

== Implementación
- Descripción de los métodos del archivo _sql.go_:
* _CrearDB()_: Creación de la Base de Datos.
* _CrearTablas()_: Creación de las tablas especificadas.
* _CrearPKyFK()_: Utiliza los métodos _crearPK()_ y _crearFK()_ respectivamente.
* _EliminarPKyFK()_: Utiliza los métodos _eliminarPK()_ y _eliminarFK()_ respectivamente.
* _CargarDatos()_: Carga la cantidad de datos especificada en las tablas: _cliente_ y _comercio_. Genera los cierres para el año 2020, llamando a _ _generarCierres()._
* _generarCierres()_: Crea una _stored procedure_ que toma como parámetro el año y genera los cierres para ese año, para cada terminación posible.
* _generarCierres()_: Invoca a la función anterior para generar los cierres del 2020.
* _autorizarCompra()_: Crea una _stored procedure_ con parámetros: _nrotarjeta, codseguridad, nrocomercio_, y _monto_. Devuelve _true_ si la compra fue autorizada y _false_ si fue rechazada.
* _generarConsumo()_: Crea una _stored procedure_ con parámetro: _cantidad_. Genera la cantidad de consumos especificada, obteniendo los datos aleatoriamente de las tablas _comercio_ y _tarjeta_. Genera un _monto_ aleatorio.
* _crearTriggerConsumo()_: Llama a la función _agregarTestConsumo()_ para crear la función _testear_consumo()_. Crea un _trigger_ que se activa antes de cada _insert_ en la tabla _consumo_. Por cada fila insertada, ejecuta la función _testear_consumo()_.
* _agregarTestConsumo()_: Crea una _stored procedure_ que llama a la función _autorizarcompra_ con sus respectivos parámetros, con los valores _new_ generados en el _insert_.
* _GenerarLogicaConsumo()_ :Llama a las funciones: _autorizarCompra, crearTriggerRechazo, crearTriggerConsumo, generarConsumo_. Para generar las _stored procedures_ y _triggers_ relacionados a los consumos virtuales y su testeo. 
* _agregarRechazo()_: Crea una _stored procedure_ que toma como parámetros: _nrotarjeta, nrocomercio, fecha_ y _motivo_ e inserta esos valores en la tabla _rechazo_. Invoca a la función _ChequearRechazoLimites(nrorechazo)_. 
* _crearTriggerRechazo()_: Crea un _trigger_ que antes de cada _insert_ en _rechazo_, por cada fila insertada llama a la función _agregar_alerta()_.
* _agregarAlertaRechazo()_: Crea una _stored procedure agregar_alerta_ que agrega una _alerta_ con los valores a insertar en la tabla _rechazo_. Con _codalerta:_ 0. Correspondiente a alertas generadas por rechazo.
* _GenerarLogicaAlertas()_: Se encarga de invocar a las funciones _crearTriggerRechazo()_ y _crearTriggerSeguridad()_ para generar los _triggers_ correspondientes.
* _crearTriggerSeguridad()_: Llama a la función _seguridadCompras_ para crear la función _compras_lapso_tiempo_. Crea un _trigger_ que se activa antes de cada _insert_ en la tabla _compra_. Por cada fila insertada, ejecuta la función _compras_lapso_tiempo()_.
* _seguridadCompras()_: Es la encargada de crear la función del _trigger_ _compras_lapso_tiempo_. Esta función checkea que las compras en un lapso de tiempo para una tarjeta en diferentes comercios estén dentro del requerimiento solicitado. En caso de detectar dos compras con lapso menor a un minuto ubicadas en el mismo código postal, se deberá insertar una _alerta_ con _codalerta_: 1. En caso de detectar dos compras con lapso menor a 5 minutos con diferentes códigos postales se deberá insertar una nueva _alerta_ con _codalerta_: 5.
* _chequearRechazoLimites()_: Crea una _stored procedure_ que toma como parámetro: nrorechazo. Detecta si la tarjeta registra dos rechazos por exceso de límite en el mismo día. En ese caso, cambia el _estado_ de la _tarjeta_ a _suspendida_ e inserta una nueva _alerta_ con _codalerta_: 32.
* _GenerarResumen()_: Crea una _stored procedure_ que toma como parámetros: _nrocliente, año, mes_ y retorna _true_ si se ha podido generar el resumen y _false_ en caso contrario. Para generarlo, se utiliza la terminación de la tarjeta del _cliente_ y se busca el período solicitado con esa terminación en la tabla _cierre_. En caso de poder generar el resumen, marca las compras involucradas como pagadas.

- Descripción de los métodos del archivo _noSQL.go_:
* _CargarDatosNoDB()_: Se conecta a la base de datos y utiliza a las funciones _CargarCliente, CargarTarjeta, CargarComercio_ y _CargarCompra_. Indicando como primer parámetro la base de datos, y luego en orden los datos de _cliente, tarjeta, comercio y compra respectivamente_. Respetando el órden y tipo de dato de sus atributos. Carga tres filas de cada tipo.
* _CargarCliente(db, nrocliente, nombre, apellido, domicilio, teléfono)_: Crea un _cliente_ utilizando el _struct Cliente_, con los parámetros especificados. Utiliza a la función _CreateUpdate_ para escribir en el _bucket_, pasándole como parámetros: la base de datos, _Cliente_ como nombre del _bucket, nrocliente_ perteneciente a _cliente_ como _string_ (clave) y un _marshaling_ de _cliente_ como valor.
* _CargarTarjeta(db, nrotarjeta, nrocliente, validadesde, validahasta, codseguridad, limitecompra, estado)_: Crea una _tarjeta_ utilizando el _struct Tarjeta_, con los parámetros especificados. Utiliza a la función _CreateUpdate_ para escribir en el _bucket_, pasándole como parámetros: la base de datos, _Tarjeta_ como nombre del _bucket_, _nrotarjeta_ perteneciente a _tarjeta_ como _string_ (clave) y un _marshaling_ de _tarjeta_ como valor.
* _CargarComercio(db, nrocomercio, nombre, domicilio, codigopostal, telefono)_: Crea un _comercio_ utilizando el _struct_ _Comercio_, con los parámetros especificados. Utiliza a la función _CreateUpdate_ para escribir en el _bucket_, pasándole como parámetros: la base de datos, _Comercio_ como nombre del _bucket_, _nrocomercio_ perteneciente a _comercio_ como _string_ (clave) y un _marshaling_ de _comercio_ como valor.
* _CargarCompra(db, nrooperacion, nrotarjeta, nrocomercio, fecha, monto, pagado)_: Crea una _compra_ utilizando el _struct Compra_, con los parámetros especificados. Utiliza a la función _CreateUpdate_ para escribir en el _bucket_, pasándole como parámetros: la base de datos, _Compra_ como nombre del _bucket, nrooperacion_ perteneciente a _compra_ como _string_ (clave) y un _marshaling_ de _compra_ como valor.
* _CreateUpdate(db, bucketName, key, value)_: Abre una transacción de escritura, crea el _bucket_ si no existe con el nombre indicado. Escribe los datos _key, value_ especificados en el _bucket_ y luego cierra la transacción.
* _ReadUnique(db, bucketName, key)_: Abre una transacción de lectura con el nombre del _bucket_ pasado como parámetro, y obtiene los datos asociados a la clave especificada.

== Conclusiones

A lo largo del desarrollo nos encontramos con algunas dificultades a la hora de trabajar sobre los requerimientos por lo que debimos consultar a los profesores.Esto nos hacia sentir un poco más próximo a un cliente.
En cuanto al desarrollo en sí, ademas de las diapositivas, tuvimos que leer bastante la documentación de postgresql para resolver las diferentes stored procedures y triggers que se nos presentaron.
Como conclusión final, creemos que el trabajo realizado fue muy bueno. Pudimos cumplir con todos los puntos planteados y nos complementamos bien como equipo a la hora de trabajar.
